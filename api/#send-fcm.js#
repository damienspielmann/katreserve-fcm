// api/send-fcm.js
const admin = require("firebase-admin");

function sendJson(res, status, obj) {
  res.status(status);
  res.setHeader("Content-Type", "application/json; charset=utf-8");
  // CORS permissif pour tests (ajuste le domaine en prod si besoin)
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
  res.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS");
  return res.end(JSON.stringify(obj));
}

function parseBody(req) {
  try {
    if (!req.body) return {};
    if (typeof req.body === "string") return JSON.parse(req.body);
    return req.body; // déjà objet
  } catch (e) {
    throw new Error("JSON invalid dans le corps de la requête");
  }
}

// --- Initialisation Firebase Admin (singleton) ---
let initError = null;
if (!admin.apps.length) {
  try {
    const serviceAccountJson = process.env.FIREBASE_SERVICE_ACCOUNT_JSON;
    if (!serviceAccountJson) {
      throw new Error("Variable d'environnement FIREBASE_SERVICE_ACCOUNT_JSON absente");
    }
    const serviceAccount = JSON.parse(serviceAccountJson);

    // ⚠️ Cas typique : clé privée mal formattée
    // Si tu obtiens 'PEM routines' dans les logs, vérifie les \n.
    admin.initializeApp({
      credential: admin.credential.cert(serviceAccount),
    });
  } catch (e) {
    initError = e;
    // On ne throw pas ici pour pouvoir renvoyer un message clair côté requête
    console.error("[init] Firebase Admin init error:", e);
  }
}

module.exports = async (req, res) => {
  // Pré-CORS
  if (req.method === "OPTIONS") {
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
    res.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS");
    return res.status(200).end();
  }

  if (req.method !== "POST") {
    return sendJson(res, 405, { error: "Méthode non autorisée. Utilise POST." });
  }

  if (initError) {
    return sendJson(res, 500, {
      error: "Firebase Admin non initialisé",
      detail: String(initError.message || initError),
    });
  }

  const API_SECRET = process.env.API_SECRET;
  if (!API_SECRET) {
    return sendJson(res, 500, { error: "API_SECRET manquant dans les variables d'environnement" });
  }

  let body;
  try {
    body = parseBody(req);
  } catch (e) {
    return sendJson(res, 400, { error: String(e.message || e) });
  }

  // Auth simple par secret (Bearer, query ou body)
  try {
    const authHeader = req.headers["authorization"] || "";
    const bearer = authHeader.startsWith("Bearer ") ? authHeader.slice(7) : null;
    const secret = bearer || req.query?.secret || body?.secret;
    if (secret !== API_SECRET) {
      return sendJson(res, 401, { error: "Unauthorized (secret invalide)" });
    }
  } catch (e) {
    return sendJson(res, 401, { error: "Unauthorized (analyse header/query/body)" });
  }

  try {
    const { token, notification, data, android, apns, webpush } = body || {};
    if (!token || !notification) {
      return sendJson(res, 400, { error: "Requiert 'token' et 'notification'." });
    }

    const message = { token, notification, data, android, apns, webpush };
    const id = await admin.messaging().send(message);
    return sendJson(res, 200, { id });
  } catch (e) {
    console.error("[send-fcm] Error:", e);
    return sendJson(res, 500, { error: String(e.message || e) });
  }
};
